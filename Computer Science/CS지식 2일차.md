#### 라이브러리
공통으로 사용될 수 있는 특정 기능들을 모듈화한 것
폴더명, 파일명 등에 대한 규칙이 없고 프레임워크에 비해 자유로움
무언가를 자를 때 ‘도구’인 ‘가위’를 사용해서 ‘내가’ 직접 컨트롤하는데, 라이브러리가 이와 비슷하다.

#### 프레임워크
공통으로 사용될 수 있는 특정 기능들을 모듈화한 것
폴더명, 파일명 등에 대한 규칙이 있고 라이브러리에 비해 더 엄격함
다른 곳으로 이동할 때 ‘도구’인 비행기를 타고 이동하지만 ‘비행기’가 컨트롤하고 나는 가만히 있어야한다.프레임워크는 이와 비슷하다

#### 클래스, 객체, 인스턴스의 개념
*클래스란*
-개념
`객체를 만들어 내기 위한 설계도 혹은 틀`
`연관되어 있는 변수와 메서드의 집합`

*객체란*
-개념
`소프트웨어 세계에 구현할 대상`
`클래스에 선언된 모양 그대로 생성된 실체`

-특징
`'클래스의 인스턴스'라고도 부른다`
`객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.`
`oop의 관점에서 클래스의 타입으로 선언되었을 때 '객체'라고 부른다.`

*인스턴스란*
-개념
`설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체`
`실체화된 인스턴스는 메모리에 할당된다.`

-특징
`인스턴스는 객체에 포함된다고 볼 수 있다.`
`oop의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 ‘인스턴스’라고 부른다.`

```javascript
/* 클래스 */
public class Animal {
  ...
}
/* 객체와 인스턴스 */
public class Main {
  public static void main(String[] args) {
    Animal cat, dog; // '객체'

    // 인스턴스화
    cat = new Animal(); // cat은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
    dog = new Animal(); // dog은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
  }
}

```
출처 : https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html`

#### 접근 지정자
`public : 모든 접근을 허용합니다. 어떠한 클래스가 접근을 하든 모두 허용됩니다.`
`protected : 상속받은 클래스 또는 같은 패키지에서만 접근이 가능합니다.`
`default : 기본 제한자로써 아무것도 붙지 않고, 자신 클래스 내부와 같은 패키지 내에서만 접근이 가능.`
`private : 외부에서 접근이 불가능합니다. 즉, 같은 클래스 내에서만 접근이 가능합니다.`



*1.1.3 전략 패턴*
전략 패턴(Strategy pattern)은 정책 패턴(policy pattern)이라고도 함.
객체의 행위를 바꾸고 싶은 경우 ‘직접’ 수정하지 않고 전략이라 부르는 ‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주며 상호 교체가 가능하게 만드는 패턴
![](https://velog.velcdn.com/images/guddyd6761/post/31bf79d7-80c8-4949-af11-0ef7a64c2a03/image.png)

#### 컨텍스트란
프로그래밍에서의 컨텍스트는 상황, 맥락, 문맥을 의미하여 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보를 말한다.

**Passport의 전략패턴**
전략패턴을 활용한 라이브러리는 passport가 있다
passport 는 Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리로,여러가지 ‘전략’을 기반으로 인증할 수 있게 한다.


*1.1.4 옵저버 패턴*
주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴
![](https://velog.velcdn.com/images/guddyd6761/post/c3d79a05-b927-4873-ac59-822006d0d997/image.png)
(객체와 주체가 분리되어 있는 옵저버 패턴)

주체 : 객체의 상태 변화를 보고 있는 관찰자
옵저버 : 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 ‘추가 변화 사항’이 생기는 객체들을 의미
![](https://velog.velcdn.com/images/guddyd6761/post/7355e407-ac08-4629-9f10-d2987e5d0ece/image.png)
(객체와 주체가 합쳐진 옵저버 패턴)

위 그림들처럼 주체 객체를 따로 두지 않고 상태가 변경되는 객체를 중심으로 구축하기도 한다
옵저버 패턴을 활용한 서비스로는 트위터가 있습니다.

![](https://velog.velcdn.com/images/guddyd6761/post/34fac65c-78b1-4ea1-87ee-92431372b091/image.png)

![](https://velog.velcdn.com/images/guddyd6761/post/2c756d8d-10d2-4c33-89b9-6319179963ea/image.png)

옵저버 패턴은 주로 이벤트 기반 시스템에 사용하며 MVC(Model-View-Controller)패턴에 사용된다.
모델에 변경사항→update()메서드로  뷰에 알림 → 컨트롤러 등 작동


**자바 : 상속과 구현**
implements 등 자바의 상속과 구현의 특징과 차이

**상속  ⇒ 일반클래스**
상속(extends)은 자식 클래스가 부모 클래스의 메서드 등을 상속받아 사용하며 자식 클래스에서 추가 및 확장을 할 수 있는 것을 의미. 재사용성,중복성의 최소화가 이뤄짐

**구현 ⇒ abstract 클래스를 기반으로 구현**
구현(implements)은 부모 인터페이스(interface)를 자식 클래스에서 재정의하여 구현하는 것
상속과는 달리 반드시 부모 클래스의 메서드를 재정의해 구현해야한다

**자바스크립트에서의 옵저버 패턴**
자바스크립트에서의 옵저버 패턴은 프록시 객체를 통해 구현
프록시(proxy) 객체는 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체를 뜻하며, 자바스크립트에서 프록시 객체는 두 개의 매개변수를 가진다.
- target : 프록시할 대상
- handler : 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정해져 있는 함수