### 1.1.5 프록시 패턴과 프록시 서버
**프록시 패턴**
대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴
![](https://velog.velcdn.com/images/guddyd6761/post/e2d0a8a1-c258-40dc-9108-42c88c99d176/image.png)
객체의 속성,변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용
프록시 객체로 쓰이기도 하나, 프록시 서버로 활용되기도 한다.

**프록시 서버에서의 캐싱**
`캐시 안에 정보를 담아두어, 캐시 내 정보를 요청 시에 원격 서버 내에 요청을 하지 않고 캐시 안에 데이터를 활용하는 것을 말한다. 불필요하게 외부와 연결되지 않기에 트래픽을 줄일 수 있는 장점이 있다.`


**프록시 서버**
서버와 클라이언트 사이에, 클라이언트가 자신을 통해 타 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램


**프록시 서버로 쓰는 nginx**
비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버이며, 주로 Node.js 서버 앞단의 프록시 서버로 활용
Node.js의 버퍼 오버플로우 취약점을 예방하기 위해서는 nginx를 프록시 서버로 앞단에 놓고 Node.js를 뒤쪽에 놓는 것이 좋다.
이러한 말은 Node.js 서버를 운영할 때 교과서처럼 참고 돼 많은 이가 이렇게 구축한다.
Node.js 서버를 구축할 때 앞단에 nginx를 두는 것이다.
이를 통해 익명 사용자의 직접적인 서버로의 접근을 차단하고 간접적으로 한 단계를 더 거침으로써 보안성을 더욱 강화할 수 있다.

![](https://velog.velcdn.com/images/guddyd6761/post/8bbffe80-b897-459f-a12b-dd9359f23030/image.png)

이처럼 nginx를 프록시 서버로 두어 실제 포트를 숨기거나,
정적 자원을 gzip 압축하거나, 메인 서버 앞단에서의 로깅을 할 수도 있다.

**버퍼 오버플로우**
`보통 데이터가 저장되는 메모리 공간, 메모리 공간으로 벗어나는 경우
이때 사용되지 않아야 할 영역에 데이터가 덮어씌워져 주소,값을 바꾸는 공격이 발생하기도 함`

**gzip 압축**
`LZ77과 Huffman 코딩의 조합인 DEFLATE 알고리즘을 기반으로 한 압축 기술
gzip 압축을 하면 데이터 전송량을 줄이나, 압축 해제 시에 서버에서의 CPU 오버헤드도 생각해서 gzip 압축 사용 유무를 결정한다`

**프록시 서버로 쓰는 CloudFlare**
CloudFlare는 전 세계적 분산된 서버가 있고 어떤 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스

CloudFlare를 사용함으로 누릴 수 있는 이점
- CDN
- DDOS 공격 방어
- HTTPS 구축

모두 웹 서버 앞단에서 '프록시 서버'로 쓰기 때문에 가능한 것
사용자, 크롤러, 공격자가 자신의 웹 사이트에 접속하게 될 텐데, 이때 CloudFlare를 통해 공격자로부터 보호가능
![](https://velog.velcdn.com/images/guddyd6761/post/6561efbf-966f-4ab3-8e12-277eec4fea31/image.png)

*DDOS 공격 방어*
DDOS : 단시간에 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격 유형
CloudFlare는 의심스러운 트래픽이나, 사용자가 접속하는 것이 아닌 시스템을 통해 오는 트래픽을 자동 차단해 DDOS 공격으로부터 보호한다. CloudFlare의 거대한 네트워크 용량과 캐싱 전략으로 소규모 DDOS는 쉽게 막으며, 이런 공격에 대한 방화벽 대시보드도 제공.

*HTTPS 구축*
서버에서 HTTPS 구축할 때 인증서를 기반으로 구축 가능
CloudFlare를 사용 시에는 별도의 인증서 설치 없이 좀 더 편하게 HTTPS를 구축 가능

**CDN(Content Delivery Network)**
`각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크를 말함
사용자가 웹 서버로부터 콘텐츠를 다운하는 시간을 줄임`


**CORS와 프론트엔드의 프록시 서버**
CORS(Cross-Origin Resource Sharing)는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘
![](https://velog.velcdn.com/images/guddyd6761/post/fbca1876-7241-4b99-a478-324cdf487ea5/image.png)
프론트엔드 개발 시 서버를 따로 만들어 백엔드 서버와 통신할 때 주로 CORS 에러를 마주한다.
예로 127.0.0.1:3000으로 프론트엔드에서 테스트 시에 백엔드 서버가 127.0.0.1:2010이라면 포트 번호가 달라 CORS 에러가 난다. 이때 프록시 서버를 둬서 프론테엔드 서버에서 요청되는 오리진을 127.0.0.1:2010로 바꿔주는 것이다.

**오리진**
`프로토콜과 호스트 이름, 포트의 조합
ex) https://veganwithbacon.tistory.com:3030/test는 주소에서 오리진은  https://veganwithbacon.tistory.com:3030을 뜻한다`


### 1.1.6 이터레이터 패턴
이터레이터 패턴은 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴입니다. 이를 통해 순회할 수 있는 여러 가지 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 순회가 가능합니다.

**자바스크립트에서의 이터레이터 패턴**

```javascript    
const mp = new Map() 
mp.set('a', 1)
mp.set('b', 2)
mp.set('cccc', 3) 
const st = new Set() 
st.add(1)
st.add(2)
st.add(3) 
const a = []
for(let i = 0; i < 10; i++)a.push(i)

for(let aa of a) console.log(aa)
for(let a of mp) console.log(a)
for(let a of st) console.log(a) 
/* 
a, b, c 
[ 'a', 1 ]
[ 'b', 2 ]
[ 'c', 3 ]
1
2
3
*/
```            


  
**이터레이터 프로토콜**
`이터러블한 객체들을 순회할 때 쓰이는 규칙`
  
**이터러블한 객체**
`반복 가능한 객체로 배열을 일반화한 객체`
  
  
#### 1.1.7 노출모듈 패턴
노출모듈 패턴은 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴을 말합니다. 자바스크립트는 private나 publick 같은 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행됩니다. 그렇기 때문에 노출모듈 패턴을 통해 private와 public 접근 제어자를 구현하기도 합니다.


```javascript
    const pukuba = (() => {
    const a = 1
    const b = () => 2
    const public = {
        c : 2, 
        d : () => 3
    }
    return public 
})() 
console.log(pukuba)
console.log(pukuba.a)
// { c: 2, d: [Function: d] }
// undefined
// a와 b는 다른 모듈에서 사용할 수 없는 변수나 함수이며 private 범위를 가지고,
// c와 d는 다른 모듈에서 사용할 수 있는 변수나 함수이며 publick 범위를 가진다.
// 노출모듈 패턴을 기반으로 만든 자바스크립트 모듈 방식으로는 CJS모듈 방식이 있다.
 ```

**public**
`클래스에 정의된 함수에서 접근 가능하며 자식 클래스와 외부 클래스에서 접근 가능한 범위`

**protected**
`클래스에 정의된 함수에서 접근 가능, 자식 클래스에서 접근 가능하지만 외부 클래스에서 접근 불가능한 범위`

**private**
`클래스에 정의된 함수에서 접근 가능하지만 자식 클래스와 외부 클래스에서 접근 불가능한 범위`

**즉시 실행 함수**
`함수를 정의하자마자 바로 호출하는 함수.초기화 코드, 라이브러리 내 전역 변수의 충돌 방지 등에 사용한다.`